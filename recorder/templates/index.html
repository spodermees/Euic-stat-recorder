<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Showdown Recorder</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body data-active-team-id="{{ active_team.id }}">
    <header class="app-header">
        <div>
            <h1>Showdown Recorder</h1>
            <p>Upload a chat log to extract items and damage ranges.</p>
        </div>
        <div class="actions">
            <a class="button" id="prep-link" href="{{ url_for('prep', team_id=active_team.id) }}">Prep</a>
            <div class="team-picker">
                <label class="sr-only" for="team-select">Team</label>
                <select id="team-select" aria-label="Selecteer team">
                    {% for team in teams %}
                        <option value="{{ team.id }}" {% if team.id == active_team.id %}selected{% endif %}>{{ team.name }}</option>
                    {% endfor %}
                </select>
            </div>
            <button class="button-outline" id="team-add" type="button">+ Team</button>
        </div>
        <div class="stat">
            <span>Total events</span>
            <strong>{{ totals.total_events or 0 }}</strong>
        </div>
        <div class="rating-wrapper" id="rating-wrapper">
            <div class="rating rating-clickable" id="rating-card" aria-live="polite" role="button" tabindex="0" aria-expanded="false">
                <span>Current rating</span>
                <strong id="rating-elo">...</strong>
                <small id="rating-format" class="muted">Loading...</small>
                <small class="muted">Klik voor graph</small>
            </div>
            <div class="rating-chart" id="rating-chart" role="dialog" aria-label="Rating history" hidden>
                <div class="rating-chart-header">
                    <span>Rating history</span>
                    <span id="rating-chart-range" class="muted"></span>
                </div>
                <canvas id="rating-canvas" width="240" height="130"></canvas>
                <div class="rating-chart-empty muted" id="rating-chart-empty">Nog geen rating data.</div>
            </div>
        </div>
    </header>

    <main class="container">
        <section class="card">
            <h2>Overall damage (all matches)</h2>
            {% if damage_stats.total_hits %}
                <div class="summary">
                    <span class="chip damage">Min {{ '%.1f'|format(damage_stats.min_damage) }}%</span>
                    <span class="chip damage">Max {{ '%.1f'|format(damage_stats.max_damage) }}%</span>
                    <span class="chip">Avg {{ '%.1f'|format(damage_stats.avg_damage) }}%</span>
                    <span class="muted">{{ damage_stats.total_hits }} hits</span>
                </div>
                {% if attacker_options and opponent_options %}
                    <form class="form-grid" method="get" action="{{ url_for('index', team_id=active_team.id) }}" style="margin-top:16px;">
                        <input type="hidden" name="team_id" value="{{ active_team.id }}">
                        <label>
                            Mijn Pokémon
                            <select name="attacker" class="js-searchable-select" required>
                                <option value="" disabled {% if not attacker %}selected{% endif %}>Selecteer mijn Pokémon</option>
                                {% for name in attacker_options %}
                                    <option value="{{ name }}" {% if attacker == name %}selected{% endif %}>{{ name }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <label>
                            Tegenstander Pokémon
                            <select name="defender" class="js-searchable-select" required>
                                <option value="" disabled {% if not defender %}selected{% endif %}>Selecteer tegenstander</option>
                                {% for name in opponent_options %}
                                    <option value="{{ name }}" {% if defender == name %}selected{% endif %}>{{ name }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <button type="submit">Toon dmg range</button>
                    </form>

                    {% if damage_lookup %}
                        <div class="damage-dual">
                            <div>
                                <h3>{{ damage_lookup.attacker }} → {{ damage_lookup.defender }}</h3>
                                {% if damage_lookup.forward %}
                                    <div class="list">
                                        {% for item in damage_lookup.forward %}
                                            <div class="list-item">
                                                <div>
                                                    <strong>{{ item.move }}</strong>
                                                    <span>{{ '%.1f'|format(item.min_low) }}% - {{ '%.1f'|format(item.max_high) }}%</span>
                                                    <span>Avg {{ '%.1f'|format(item.avg) }}%</span>
                                                    <span class="muted">{{ item.count }} hits</span>
                                                </div>
                                                <div class="list-actions">
                                                    {% if item.replay_url %}
                                                        <a class="chip" href="{{ item.replay_url }}" target="_blank" rel="noreferrer">Replay</a>
                                                    {% else %}
                                                        <span class="chip">Geen replay</span>
                                                    {% endif %}
                                                    <a class="chip" href="https://play.pokemonshowdown.com/" target="_blank" rel="noreferrer">Showdown</a>
                                                </div>
                                            </div>
                                        {% endfor %}
                                    </div>
                                {% else %}
                                    <p class="muted">Geen dmg gevonden.</p>
                                {% endif %}
                            </div>
                            <div>
                                <h3>{{ damage_lookup.defender }} → {{ damage_lookup.attacker }}</h3>
                                {% if damage_lookup.reverse %}
                                    <div class="list">
                                        {% for item in damage_lookup.reverse %}
                                            <div class="list-item">
                                                <div>
                                                    <strong>{{ item.move }}</strong>
                                                    <span>{{ '%.1f'|format(item.min_low) }}% - {{ '%.1f'|format(item.max_high) }}%</span>
                                                    <span>Avg {{ '%.1f'|format(item.avg) }}%</span>
                                                    <span class="muted">{{ item.count }} hits</span>
                                                </div>
                                                <div class="list-actions">
                                                    {% if item.replay_url %}
                                                        <a class="chip" href="{{ item.replay_url }}" target="_blank" rel="noreferrer">Replay</a>
                                                    {% else %}
                                                        <span class="chip">Geen replay</span>
                                                    {% endif %}
                                                    <a class="chip" href="https://play.pokemonshowdown.com/" target="_blank" rel="noreferrer">Showdown</a>
                                                </div>
                                            </div>
                                        {% endfor %}
                                    </div>
                                {% else %}
                                    <p class="muted">Geen dmg gevonden.</p>
                                {% endif %}
                            </div>
                        </div>
                    {% else %}
                        <p class="damage-details">Selecteer twee Pokémon om de dmg range te zien.</p>
                    {% endif %}
                {% endif %}
            {% else %}
                <p>No damage data yet. Import a replay or upload a log.</p>
            {% endif %}
        </section>

        <section class="card">
            <h2>Import replay URL</h2>
            <form class="form-grid" id="replay-form">
                <label>
                    Battle replay URL
                    <input type="text" name="replay_url" placeholder="https://replay.pokemonshowdown.com/gen9randombattle-1234567890">
                </label>
                <button type="submit">Import replay</button>
            </form>
            <p class="hint" id="replay-status">Paste a replay URL to import the full chat log.</p>
        </section>

        <section class="card">
            <h2>Import Pokepaste (nicknames)</h2>
            <form class="form-grid" id="pokepaste-form">
                <label>
                    Pokepaste URL
                    <input type="text" name="pokepaste_url" placeholder="https://pokepast.es/....">
                </label>
                <button type="submit">Import nicknames</button>
            </form>
            <p class="hint" id="pokepaste-status">Plak een Pokepaste link om nicknames op te slaan bij het team.</p>
            {% if team_pokemon %}
                <div class="list" style="margin-top: 16px;">
                    {% for item in team_pokemon %}
                        <div class="list-item">
                            <div>
                                <strong>{{ item.nickname }}</strong>
                                {% if item.species %}
                                    <span class="muted">({{ item.species }})</span>
                                {% endif %}
                            </div>
                            {% if item.source_url %}
                                <div class="list-actions">
                                    <a class="chip" href="{{ item.source_url }}" target="_blank" rel="noreferrer">Pokepaste</a>
                                </div>
                            {% endif %}
                        </div>
                    {% endfor %}
                </div>
            {% else %}
                <p class="muted" style="margin-top: 12px;">Nog geen nicknames opgeslagen voor dit team.</p>
            {% endif %}
        </section>

        <section class="card">
            <h2>Import replay list (.txt)</h2>
            <form class="form-grid" id="replay-bulk-form">
                <label>
                    Replay list file (.txt)
                    <input type="file" name="replay_file" accept=".txt">
                </label>
                <button type="submit">Import list</button>
            </form>
            <p class="hint" id="replay-bulk-status">One replay URL per line (or paste multiple URLs in one line).</p>
        </section>

        <section class="card">
            <h2>Import replays.txt (server)</h2>
            <form class="form-grid" id="replay-file-form">
                <button type="submit">Import &amp; clear replays.txt</button>
            </form>
            <p class="hint" id="replay-file-status">Uses recorder/replays.txt on the server and clears it after import.</p>
        </section>

        <section class="card">
            <details class="collapsible" open>
                <summary>
                    <h2>Matches</h2>
                    <span class="muted">Toon/verberg lijst</span>
                </summary>
                {% if matches %}
                    <div class="list" style="margin-top: 16px;">
                        {% for match in matches %}
                            <div class="list-item">
                                <div>
                                    <strong>{{ match.name }}</strong>
                                    <span>{{ match.format or 'Unknown format' }} · {{ match.created_at }}</span>
                                    <span>Winner: {{ match.winner or 'Unknown' }}{% if match.result %} · {{ match.result }}{% endif %}</span>
                                </div>
                                <div class="list-actions">
                                    {% if match.replay_url %}
                                        <a class="chip" href="{{ match.replay_url }}" target="_blank" rel="noreferrer">Replay</a>
                                    {% else %}
                                        <span class="chip">Geen replay</span>
                                    {% endif %}
                                    <a class="chip" href="{{ url_for('match_log', match_id=match.id) }}">Log</a>
                                    <a class="chip" href="https://play.pokemonshowdown.com/" target="_blank" rel="noreferrer">Showdown</a>
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                {% else %}
                    <p>No matches yet. Upload a log to get started.</p>
                {% endif %}
            </details>
        </section>
    </main>

    <script>
        const replayForm = document.getElementById('replay-form');
        const replayStatus = document.getElementById('replay-status');
        const replayBulkForm = document.getElementById('replay-bulk-form');
        const replayBulkStatus = document.getElementById('replay-bulk-status');
        const replayFileForm = document.getElementById('replay-file-form');
        const replayFileStatus = document.getElementById('replay-file-status');
        const pokepasteForm = document.getElementById('pokepaste-form');
        const pokepasteStatus = document.getElementById('pokepaste-status');
        const searchableSelects = document.querySelectorAll('.js-searchable-select');
        const ratingElo = document.getElementById('rating-elo');
        const ratingFormat = document.getElementById('rating-format');
        const ratingWrapper = document.getElementById('rating-wrapper');
        const ratingCard = document.getElementById('rating-card');
        const ratingChart = document.getElementById('rating-chart');
        const ratingCanvas = document.getElementById('rating-canvas');
        const ratingChartEmpty = document.getElementById('rating-chart-empty');
        const ratingChartRange = document.getElementById('rating-chart-range');
        let ratingHistoryLoaded = false;
        let ratingHistoryPoints = [];
        let ratingChartMeta = null;

        const activeTeamId = Number(document.body?.dataset?.activeTeamId || '');
        const teamAddButton = document.getElementById('team-add');

        replayForm?.addEventListener('submit', async (event) => {
            event.preventDefault();
            const input = replayForm.querySelector('input[name="replay_url"]');
            const url = input?.value?.trim();
            if (!url) {
                replayStatus.textContent = 'Enter a replay URL first.';
                return;
            }
            replayStatus.textContent = 'Importing replay...';
            try {
                const response = await fetch('/api/ingest_replay', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url, team_id: activeTeamId })
                });
                const payload = await response.json();
                if (response.ok) {
                    replayStatus.textContent = 'Replay imported. Open it from the matches list.';
                    input.value = '';
                    window.location.reload();
                } else {
                    replayStatus.textContent = payload.message || 'Replay import failed.';
                }
            } catch (err) {
                replayStatus.textContent = 'Replay import failed.';
            }
        });

        const extractUrls = (text) => {
            const lines = text.split(/\r?\n/).map((line) => line.trim()).filter(Boolean);
            const urls = [];
            const seen = new Set();
            lines.forEach((line) => {
                const matches = line.match(/https?:\/\/\S+/gi);
                if (matches && matches.length) {
                    matches.forEach((url) => {
                        if (!seen.has(url)) {
                            seen.add(url);
                            urls.push(url);
                        }
                    });
                } else if (!seen.has(line)) {
                    seen.add(line);
                    urls.push(line);
                }
            });
            return urls;
        };

        replayBulkForm?.addEventListener('submit', async (event) => {
            event.preventDefault();
            const fileInput = replayBulkForm.querySelector('input[name="replay_file"]');
            const file = fileInput?.files?.[0];
            if (!file) {
                replayBulkStatus.textContent = 'Select a .txt file first.';
                return;
            }
            replayBulkStatus.textContent = 'Importing replay list...';
            try {
                const text = await file.text();
                const urls = extractUrls(text);
                if (!urls.length) {
                    replayBulkStatus.textContent = 'No URLs found in the file.';
                    return;
                }
                const response = await fetch('/api/ingest_replay_bulk', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ urls, team_id: activeTeamId })
                });
                const payload = await response.json();
                if (response.ok) {
                    const summary = payload.summary || {};
                    replayBulkStatus.textContent = `Imported ${summary.ok || 0}/${summary.total || urls.length} replays.`;
                    fileInput.value = '';
                    window.location.reload();
                } else {
                    replayBulkStatus.textContent = payload.message || 'Replay list import failed.';
                }
            } catch (err) {
                replayBulkStatus.textContent = 'Replay list import failed.';
            }
        });

        replayFileForm?.addEventListener('submit', async (event) => {
            event.preventDefault();
            replayFileStatus.textContent = 'Importing replays.txt...';
            try {
                const response = await fetch(`/api/ingest_replay_file?team_id=${encodeURIComponent(activeTeamId)}`, {
                    method: 'POST'
                });
                const payload = await response.json();
                if (response.ok) {
                    const summary = payload.summary || {};
                    replayFileStatus.textContent = `Imported ${summary.ok || 0}/${summary.total || 0} replays. File cleared.`;
                    window.location.reload();
                } else {
                    replayFileStatus.textContent = payload.message || 'replays.txt import failed.';
                }
            } catch (err) {
                replayFileStatus.textContent = 'replays.txt import failed.';
            }
        });

        pokepasteForm?.addEventListener('submit', async (event) => {
            event.preventDefault();
            const input = pokepasteForm.querySelector('input[name="pokepaste_url"]');
            const url = input?.value?.trim();
            if (!url) {
                pokepasteStatus.textContent = 'Plak eerst een Pokepaste URL.';
                return;
            }
            pokepasteStatus.textContent = 'Importing nicknames...';
            try {
                const response = await fetch('/api/team_pokepaste', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url, team_id: activeTeamId })
                });
                const payload = await response.json();
                if (response.ok && payload.ok) {
                    pokepasteStatus.textContent = `Geïmporteerd: ${payload.count} nicknames.`;
                    input.value = '';
                    window.location.reload();
                } else {
                    pokepasteStatus.textContent = payload.error || 'Pokepaste import failed.';
                }
            } catch (err) {
                pokepasteStatus.textContent = 'Pokepaste import failed.';
            }
        });

        const normalizeText = (value) => (value || '').toLowerCase();

        const closeAllDropdowns = () => {
            document.querySelectorAll('.searchable-select.open').forEach((wrapper) => {
                wrapper.classList.remove('open');
            });
        };

        document.addEventListener('click', (event) => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) return;
            if (!target.closest('.searchable-select')) {
                closeAllDropdowns();
            }
        });

        searchableSelects.forEach((select) => {
            const options = Array.from(select.options).filter((option) => option.value);
            const placeholderOption = Array.from(select.options).find((option) => !option.value);
            const wrapper = document.createElement('div');
            wrapper.className = 'searchable-select';

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'searchable-input';
            input.placeholder = placeholderOption?.textContent?.trim() || 'Selecteer...';
            input.autocomplete = 'off';

            const menu = document.createElement('div');
            menu.className = 'searchable-menu';

            const list = document.createElement('div');
            list.className = 'searchable-options';

            const buildOptions = (query = '') => {
                list.innerHTML = '';
                const normalizedQuery = normalizeText(query).trim();
                const filtered = options.filter((option) => {
                    return !normalizedQuery || normalizeText(option.textContent).includes(normalizedQuery);
                });

                if (!filtered.length) {
                    const empty = document.createElement('div');
                    empty.className = 'searchable-empty';
                    empty.textContent = 'Geen resultaten.';
                    list.appendChild(empty);
                    return;
                }

                filtered.forEach((option) => {
                    const item = document.createElement('button');
                    item.type = 'button';
                    item.className = 'searchable-option';
                    item.textContent = option.textContent;
                    item.dataset.value = option.value;
                    item.addEventListener('click', () => {
                        select.value = option.value;
                        input.value = option.textContent;
                        wrapper.classList.remove('open');
                    });
                    list.appendChild(item);
                });
            };

            buildOptions();

            input.addEventListener('input', () => {
                buildOptions(input.value);
                wrapper.classList.add('open');
            });

            input.addEventListener('focus', () => {
                closeAllDropdowns();
                buildOptions(input.value);
                wrapper.classList.add('open');
            });

            menu.appendChild(list);
            wrapper.appendChild(input);
            wrapper.appendChild(menu);

            select.classList.add('searchable-hidden');
            select.parentNode.insertBefore(wrapper, select);
        });

        const loadRating = async () => {
            if (!ratingElo || !ratingFormat) return;
            try {
            const response = await fetch(`/api/showdown_rating?user=spodermees&team_id=${encodeURIComponent(activeTeamId)}`);
                const payload = await response.json();
                if (!response.ok || !payload.ok) {
                    ratingElo.textContent = 'N/A';
                    ratingFormat.textContent = 'Geen rating gevonden';
                    return;
                }
                if (!payload.rating) {
                    ratingElo.textContent = 'N/A';
                    ratingFormat.textContent = 'Geen ladder data';
                    return;
                }
                ratingElo.textContent = Math.round(payload.rating.elo).toString();
                const format = payload.rating.format || 'Unknown format';
                const normalizedFormat = format.toLowerCase();
                if (normalizedFormat.includes('randomdoubles')) {
                    ratingFormat.textContent = 'gen9regfdoubles best of 3';
                } else {
                    ratingFormat.textContent = format;
                }
            } catch (err) {
                ratingElo.textContent = 'N/A';
                ratingFormat.textContent = 'Kan rating niet laden';
            }
        };

        loadRating();

        const drawRatingChart = () => {
            if (!ratingCanvas || !ratingChartEmpty || !ratingChartRange) return;
            const ctx = ratingCanvas.getContext('2d');
            if (!ctx) return;

            const points = ratingHistoryPoints;
            ctx.clearRect(0, 0, ratingCanvas.width, ratingCanvas.height);

            if (!points.length) {
                ratingChartEmpty.style.display = 'block';
                ratingChartRange.textContent = '';
                return;
            }

            ratingChartEmpty.style.display = 'none';

            const elos = points.map((point) => point.elo);
            let minElo = Math.min(...elos);
            let maxElo = Math.max(...elos);
            if (minElo === maxElo) {
                minElo -= 10;
                maxElo += 10;
            }
            ratingChartRange.textContent = `${minElo} - ${maxElo}`;

            const paddingX = 34;
            const paddingY = 18;
            const width = ratingCanvas.width - paddingX * 2;
            const height = ratingCanvas.height - paddingY * 2;

            const tickStep = 50;
            const tickMin = Math.floor(minElo / tickStep) * tickStep;
            const tickMax = Math.ceil(maxElo / tickStep) * tickStep;

            ctx.strokeStyle = '#1f2538';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let value = tickMin; value <= tickMax; value += tickStep) {
                const normalized = (value - minElo) / (maxElo - minElo || 1);
                const y = paddingY + height - normalized * height;
                ctx.moveTo(paddingX, y);
                ctx.lineTo(paddingX + width, y);
            }
            ctx.stroke();

            ctx.fillStyle = '#9aa4c7';
            ctx.font = '10px "Segoe UI", system-ui, sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let value = tickMin; value <= tickMax; value += tickStep) {
                const normalized = (value - minElo) / (maxElo - minElo || 1);
                const y = paddingY + height - normalized * height;
                const clampedY = Math.min(Math.max(y, paddingY), paddingY + height);
                ctx.fillText(String(value), paddingX - 8, clampedY);
            }

            ctx.strokeStyle = '#4c6fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const plotted = points.map((point, index) => {
                const x = paddingX + (width * index) / Math.max(points.length - 1, 1);
                const normalized = (point.elo - minElo) / (maxElo - minElo || 1);
                const y = paddingY + height - normalized * height;
                return { x, y, elo: point.elo, created_at: point.created_at };
            });

            plotted.forEach((point, index) => {
                if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            ctx.stroke();

            ctx.fillStyle = '#8cc6ff';
            plotted.forEach((point) => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 2.8, 0, Math.PI * 2);
                ctx.fill();
            });

            ratingChartMeta = {
                paddingX,
                paddingY,
                width,
                height,
                points: plotted,
            };
        };

        const loadRatingHistory = async () => {
            if (ratingHistoryLoaded) return;
            ratingHistoryLoaded = true;
            try {
            const response = await fetch(`/api/rating_history?user=spodermees&team_id=${encodeURIComponent(activeTeamId)}`);
                const payload = await response.json();
                if (!response.ok || !payload.ok) {
                    ratingHistoryPoints = [];
                    drawRatingChart();
                    return;
                }
                ratingHistoryPoints = (payload.points || []).map((point) => ({
                    elo: Number(point.elo),
                    created_at: point.created_at,
                }));
                drawRatingChart();
            } catch (err) {
                ratingHistoryPoints = [];
                drawRatingChart();
            }
        };

        const formatDate = (value) => {
            if (!value) return '';
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) return value;
            return date.toLocaleDateString('nl-NL', { day: '2-digit', month: 'short' });
        };

        const updateRatingTooltip = (event) => {
            if (!ratingChart || !ratingCanvas || !ratingChartMeta) return;
            const rect = ratingCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const scaleX = ratingCanvas.width / rect.width;
            const scaleY = ratingCanvas.height / rect.height;
            const canvasX = x * scaleX;
            const canvasY = y * scaleY;

            let hit = null;
            for (const point of ratingChartMeta.points) {
                const dx = canvasX - point.x;
                const dy = canvasY - point.y;
                if (Math.sqrt(dx * dx + dy * dy) <= 6) {
                    hit = point;
                    break;
                }
            }

            if (!hit) {
                ratingChart.removeAttribute('data-tooltip');
                return;
            }

            ratingChart.dataset.tooltip = `${hit.elo}${hit.created_at ? ` · ${formatDate(hit.created_at)}` : ''}`;
            ratingChart.style.setProperty('--tooltip-x', `${Math.round(hit.x)}px`);
            ratingChart.style.setProperty('--tooltip-y', `${Math.round(hit.y)}px`);
        };

        const closeRatingChart = () => {
            ratingWrapper?.classList.remove('open');
            if (ratingChart) {
                ratingChart.hidden = true;
            }
            ratingCard?.setAttribute('aria-expanded', 'false');
        };

        const toggleRatingChart = async () => {
            if (!ratingWrapper || !ratingChart || !ratingCard) return;
            const isOpen = ratingWrapper.classList.contains('open');
            if (isOpen) {
                closeRatingChart();
                return;
            }
            ratingWrapper.classList.add('open');
            ratingChart.hidden = false;
            ratingCard.setAttribute('aria-expanded', 'true');
            await loadRatingHistory();
        };

        ratingCard?.addEventListener('click', (event) => {
            event.preventDefault();
            toggleRatingChart();
        });

        ratingCard?.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                toggleRatingChart();
            }
        });

        ratingCanvas?.addEventListener('mousemove', updateRatingTooltip);
        ratingCanvas?.addEventListener('mouseleave', () => {
            ratingChart?.removeAttribute('data-tooltip');
        });

        const teamSelect = document.getElementById('team-select');
        const prepLink = document.getElementById('prep-link');
        const updatePrepLink = () => {
            if (!prepLink || !teamSelect?.value) return;
            prepLink.href = `/prep?team_id=${encodeURIComponent(teamSelect.value)}`;
        };
        updatePrepLink();
        teamSelect?.addEventListener('change', () => {
            const value = teamSelect.value;
            if (value) {
                window.location.href = `/?team_id=${encodeURIComponent(value)}`;
            }
        });

        teamAddButton?.addEventListener('click', async () => {
            const name = window.prompt('Team naam?');
            if (!name) return;
            try {
                const response = await fetch('/api/prep_teams', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                const payload = await response.json();
                if (response.ok && payload.ok) {
                    window.location.href = `/?team_id=${encodeURIComponent(payload.id)}`;
                }
            } catch (err) {
                // ignore
            }
        });

        document.addEventListener('click', (event) => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) return;
            if (!target.closest('#rating-wrapper')) {
                closeRatingChart();
            }
        });
    </script>
</body>
</html>
